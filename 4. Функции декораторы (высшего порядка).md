# Функции высшего порядка

# План занятия

1. memoization
2. spy
3. debounce
4. throttle

## Вспомним

> Функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

Мы уже знакомы с функциями, которые манипулирует переменными в замыкании, при этом доступа к самой переменной извне нет, кроме как с помощью возвращенных функций.

Также многие методы массива, такие как map, filter являются функциями высшего порядка, так как принимают функции в качестве аргументов.

Крайне распространенный и полезный паттерн, которым надо уметь пользоваться

## Memoization

Часто возникает задача сделать так, чтобы функция кэшировала результат своего выполнения.

Это можно реализовать используя внешние переменные:

```js
let cache = {}
function add(a, b) {
  const hash = "a" + a + "b" + b

  if (hash in cache) {
    console.log("Из кэша")
    console.log(cache[hash])
  } else {
    console.log("Вычисляем")
    let result = a + b
    cache[hash] = result
    console.log(result)
  }
}

add(1, 5) // вычисляем 6
add(1, 5) // из кэша 6
add(10, 200) // вычисляем 210
add(10, 200) // из кэша 210
add(1, 5) // из кэша 6
```

## Кэширующий декоратор

Как сделать декорирование универсальным? Напишем функцию обертку.

```js
function decorator(inFunction) {
  let cache = {}
  // Создадим функцию обертку и вернем её
  function wrapper(...args) {
    const hash = "a" + a + "b" + b

    if (hash in cache) {
      console.log("Из кэша")
      console.log(cache[hash])
    } else {
      console.log("Вычисляем")
      let result = inFunction(args)
      cache[hash] = result
      console.log(result)
    }
  }
  return wrapper
}
```

## Использование

```js
const add = (a, b) => a + b

const memoizedAdd = decorator(add)
memoizedAdd(10, 51)
memoizedAdd(10, 51)
```
