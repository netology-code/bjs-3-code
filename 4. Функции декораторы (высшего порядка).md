# Функции высшего порядка

# План занятия

1. memoization
2. spy
3. debounce
4. throttle

## Вспомним

> Функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

Мы уже знакомы с функциями, которые манипулирует переменными в замыкании, при этом доступа к самой переменной извне нет, кроме как с помощью возвращенных функций.

Также многие методы массива, такие как map, filter являются функциями высшего порядка, так как принимают функции в качестве аргументов.

Крайне распространенный и полезный паттерн, которым надо уметь пользоваться

## Memoization

Часто возникает задача сделать так, чтобы функция кэшировала результат своего выполнения.

Это можно реализовать используя внешние переменные:

```js
let cache = {};
function add(a, b) {
  const hash = "a" + a + "b" + b;

  if (hash in cache) {
    console.log("Из кэша");
    console.log(cache[hash]);
  } else {
    console.log("Вычисляем");
    let result = a + b;
    cache[hash] = result;
    console.log(result);
  }
}

add(1, 5); // вычисляем 6
add(1, 5); // из кэша 6
add(10, 200); // вычисляем 210
add(10, 200); // из кэша 210
add(1, 5); // из кэша 6
```

## Кэширующий декоратор

Как сделать декорирование универсальным? Напишем функцию обертку.

```js
function decorator(inFunction) {
  let cache = {};
  // Создадим функцию обертку и вернем её
  function wrapper(...args) {
    const hash = "a" + a + "b" + b;

    if (hash in cache) {
      console.log("Из кэша");
      console.log(cache[hash]);
    } else {
      console.log("Вычисляем");
      let result = inFunction(args);
      cache[hash] = result;
      console.log(result);
    }
  }
  return wrapper;
}
```

## Использование

```js
const add = (a, b) => a + b;

const memoizedAdd = decorator(add);
memoizedAdd(10, 51);
memoizedAdd(10, 51);
```
