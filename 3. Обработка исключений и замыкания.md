# 3.1. Обработка исключений и замыкания.

# План занятия

1. Внутренние исключений выполнения
2. Создание собственных исключений
3. Перехват исключений
4. Консольные методы для удобной работы
5. Области видимости
6. Замыкания

# Вспомним прошлый материал

Что будет выведено?

```javascript
let person = {
  name: "Олег",
  printName: () => this.name,
};
console.log(person.printName()); // ?
```

---

## Внутренние исключений выполнения

Откуда появляются ошибки?
Некоторые стандартные ситуации не должны происходить.

```js
let age = null.age;
//Uncaught TypeError: Cannot read property 'age' of null
```

Если интерпретатор не может выполнить команду, он выбрасывает ошибку.

---

# Создание собственных исключений

## Свои исключения

А можем ли мы сами выбрасывать исключения? Если да, то как и когда?

```js
const divider = (a, b) => a / b;
console.log(divider(1, 0)); // Infinity;
```

Вопрос: как запретить деление на 0?

---

## Свои исключения

Иногда возникают исключительные ситуации, которые, с точки зрения интерпретатора, ошибкой не считаются, но ошибка проявится позже - например, недополучены какие-то параметры с сервера.
Или может произойти ошибка со стороны бизнес-логики - например, недопустимое значение исходных данных.
С точки зрения интерпретатора, такие случаи ошибками не считаются, однако, с точки зрения разработччика - они являются ошибками.
В таких случаях требуется генерировать свои ошибки.

Для выбрасывания исключения используется конструкция `throw`.

```js
const divider = (a, b) => {
  if (b == 0) throw "Ошибка деления на 0";

  return a / b;
};
console.log(divider(1, 2)); // 0.5;
console.log(divider(1, 0)); // "Ошибка деления на 0";
```

![](https://psv4.userapi.com/c856536/u39946498/docs/d17/b759634d4fe3/1.png?extra=ocSzzLvKqtqcQKJftZbFvcC6xHBjkfureZr-wyHBhTn0xMlgO4R4YtyZxcTjAEU9TgDqsfpZkCotSWXg4zZV9InMIsDfa6F7T6lDoTTn1JyKUUySNw2-c9JIp8XIFbvmfV2fcifnMpKBsfIzN4Go)

---

## Объект ошибки

Примитивы, вроде текста или чисел не используются как ошибки. Для ошибок существует класс `Error`.

```js
const divider = (a, b) => {
  if (b !== 0) {
    const divideError = new Error("Ошибка деления на 0");
    throw divideError;
    // или throw new Error("Ошибка деления на 0");
  }

  return a / b;
};
console.log(divider(1, 2)); // 0.5;
console.log(divider(1, 0)); // "Ошибка деления на 0";
```

![](https://psv4.userapi.com/c856536/u39946498/docs/d7/c4a0abd1b450/2.png?extra=-6wO3kw7ntwU38BVpSpDAo1fjB0g-kdfdNz4kuLbFryflANkiktQEtIIewhxYLaM_gA5qQPdbWXGb39o7Vn8F7LLgYpDfjzP1jkA7lzFO9K4ao6ODPoIDVT78zS1yW7DqEZepHMXSZBmR6ka4eW9)

---

# Перехват исключений

## Зачем перехватывать исключения?

Если Вы скажете, что ошибки надо решать, а не прятать, я полностью с Вами соглашусь.
Однако, всегда ли наличие ошибки зависит от Вас?

Может ли быть ситуация, при которой может произойти ошибка, несмотря на то, что написанный Вами код полностью корректен?

---

Например:

- нельзя гарантировать, что необходимые данные получены с сервера;
- нельзя гарантировать, что сторонний сервис всегда доступен и корректно работает;
- нельзя гарантировать, что автор библиотеки (или тот, кто использует Вашу библиотеку) так же добросовестно пишет код, как и Вы;
- нельзя гарантировать, что пользователь не сможет ввести некорректные данные (хоть и надо к этому стремиться).

---

## Зачем перехватывать исключения?

1. Например, при возникновении ошибки необходимо сообщить об этом пользователю как-то культурно
   > В случае, если пользователь встретится с ошибкой скрипта, лучше, наверное, ему сообщить об этом ошибкой "Что-то пошло не так..." зафиксировать ошибку и дать возможность продолжить работу, а не оставить его один на один с непонятным поведением страницы?
2. Например, при возникновении ошибки необходимо получить расширенную информацию
   > При выполнении скрипта возникает ошибка. Не всегда очевидно, какие значения данных к этому приводят. В этом случае в блоке catch достаточно будет дописать вывод необходимых нам данных, приводящих к ошибке.
3. Например, случившаяся ошибка не должна прерывать выполнение дальнейшего кода
   > Подключение виджета для отображение погоды на сайте может прекратить выполнение дальнейшего кода. Лучше заранее такое предусмотреть.

---

## Как перехватывать исключения?

Конструкция `try..catch` служит для того, чтобы браузер "попытался" интерпретировать код.
Однако, если выполнить код не удастся, то можно "поймать" ошибку и/или промежуточные данные, обработать её и затем безопасно выполнять код дальше.

Конструкция `try..catch` состоит из блоков:

- try
- catch
- finally

---

## Описание блоков конструкции `try..catch`

- try
  В блоке try описывается программный код, который браузер должен "попытаться" выполнить.
- catch
  В блоке catch описывается программный код, который браузер должен выполнить, если в результате выполнения кода в блоке `try` произошла ошибка.
- finally
  В блоке finally описывается программный код, выполнение которого произойдет независимо от того, произойдёт ли ошибка в результате выполнения кода в блоке `try` или нет.

---

## Перехват исключений в действии (демо)

- try..catch

```javascript
try {
  // .. код, который может выполниться неверно
} catch (e) {
  // .. код, который в этом случае выполнится
}
```

- try..finally

```javascript
try {
  // .. код, который может выполниться неверно
} finally {
  // .. код, который выполнится в любом случае
}
```

- try..catch..finally

```javascript
try {
  // .. код, который может выполниться неверно
} catch (e) {
  // .. код, который в этом случае выполнится
} finally {
  // .. код, который выполнится в любом случае
}
```

---

## Ограничения для `try...catch`

Перехват ошибки НЕ СРАБОТАЕТ:

- если имеется **синтакcическая** ошибка;

```javascript
try{
    console.log(Ошибка не произошла!);
}catch(e){
    console.log('Ошибка произошла!');
}
// Uncaught SyntaxError: missing ) after argument list
```

В этом случае `try...catch` не будет выполняться, интерпретатор сообщит о синтаксической ошибке

---

## Ограничения для `try...catch`

Перехват ошибки НЕ СРАБОТАЕТ:

- если код, в котором произошла ошибка работает **асинхронно** по отношению к `try...catch`.

```javascript
try {
    setTimeout(()={
        console.log(null.unknown_property);
    },200)
}catch(e){
    console.log('Ошибка произошла!');
}
// Uncaught ReferenceError: Invalid left-hand side in assignment
```

_асинхронность будет изучаться в одной из следующих лекций_

---

# Консольные методы для удобной работы

## Вывод на консоль

Всем известен вывод на консоль с помощью `console.log` используемый для вывода, но можно выводить не только сообщение.
Можно выводить:

- Сообщение
- Предупреждение
- Ошибку

![](https://psv4.userapi.com/c856536/u39946498/docs/d10/01430b97538f/3.png?extra=WrxmbBlUj4temgIkxHtjMQ3QSlgWu3hHDtg8pYp4KIY-Od-ctvwWkQBaMbLpT-lP9cCMP8cO-d4VBiPSUBj2ZTPxtaSgYN8X_uT1qH4g2i2hTeg2w-z-S2CCfUw2baCXf9z4HGidhqlC9BT0QKjA)

## Очистка консоли

После многих сообщений в выводе можно запутаться. Для очистки всего вывода можно использовать `console.clear()`.
Либо использовать кнопку кружка:
![](https://psv4.userapi.com/c856536/u39946498/docs/d10/7cf3b1757bbe/4.png?extra=4_U_85pbNQ0g9o9OEqHa-dPhLUaUiFgF2OsR4b0AF0V7oLzSCaDBul5hauLRFDP64j3oTfpmKBXwMS3geJeZW7unPHSp1PTyE1NcyLDO7GCLs8H2Znzbe1FcS0nDbbvBntKX0TBmWU8fkjE6INUQ)

## Форматированный вывод

Вы можете напечатать очень хорошую таблицу с объектами, которые вы выводите, используя `console.table()`.
![](https://psv4.userapi.com/c856536/u39946498/docs/d18/c97c4b791ed5/5.png?extra=aljqoExSu9yzXztkLyV2lvt63vUm38uyPQ76QvpfRcvhPack4IomHZ9_xcx9nHtLyOfxTPEgW75q40xzoLQZ8WuTG_Tem5_ng0dqbjsXX1_X1Gr-ln_MM3NRYzuh8lTMyu2wmjfE6VPULz7fnMXV)

## Замер времени выполнения кода

Быстро ли выполняется ваша программа? Это сложно понять, если не производить замер времени выполнения отдельных функций.
Для замера времени выполнения используются методы `console.time()` и `console.timeEnd()` (в метод передаётся id таймера).
![](https://psv4.userapi.com/c856536/u39946498/docs/d7/a1cb37db9e56/6.png?extra=WAI8YhkM48oB7-todUmK_rCsdKiLRRO0ZIHln4dEEsbXeG0WJfViAdHl_2RrR-KpP6EFi04Y8ZR6yuctb2VP4R2mrnYQqvBzyWJTNCihZXtbwHc4NzYPAT5RpxsreZRJDFhgl7jx68yRCiQM2699)
Таким образом можно получить время выполнения цикла из 10000 итераций

## Области видимости

## Глобальная область видимости

Сделаем программу, которая выводит привественное сообщение пользователю. Реализуем полноценный пример. Для этого нам понадобится HTML и JavaScript-код.

```javascript
let firstName = "Олег";
function showGreeting(person) {
  console.log(`С днём рождения, ${person}!`);
}

showGreeting(firstName);
```

## Манипуляции с консолью

Теперь откроем страницу и включим консоль.

Введём в консоль

```javascript
firstName;
```

И увидим значение, которое хранится на настоящий момент в нашей переменной.

[![2018-12-02-0-52-43.png](https://i.postimg.cc/Ssm79Lxy/2018-12-02-0-52-43.png)](https://postimg.cc/jWk707f9)

JavaScript ведёт себя так, что для него обращение к переменной _firstName_ равносильно:

```javascript
let firstName = "Олег";
function showGreeting(person) {
  console.log(`С днём рождения, ${person}!`);
}

showGreeting(firstName);
console.log(firstName); // !!!
```

Более того, если в консоли же ввести друг за другом команды:

```javascript
firstName = "Иван";
```

```javascript
showGreeting(firstName);
```

То получим текст поздравления с тем именем, которое мы установили к консоли!

[![2018-12-02-0-53-39.png](https://i.postimg.cc/P5GDZbSB/2018-12-02-0-53-39.png)](https://postimg.cc/2Vw3NWRw)

## Пошалим?

Проделаем ещё одну шалость и попробуем поменять код функции _showGreeting_. Запишем в консоль:

```javascript
showGreeting = function (person) {
  console.log(`Вас взломали, ${person}!`);
};
```

И следом запустим:

```javascript
showGreeting(firstName);
```

[![2018-12-02-0-54-34.png](https://i.postimg.cc/PxcJHhcB/2018-12-02-0-54-34.png)](https://postimg.cc/62rtLsB0)

Шалость удалась! Мы смогли подменить и функцию и переменную.

**P.S. Содержимое файлов _main.js_ и _index.html_ при таком способе не меняется. После обновления страницы значение _name_ будет снова _Олег_, а функция _showGreeting_ будет снова работать как надо.**

## Проблемы безопасности

Очевидно, что если бы наша программа была бы чуть серьёзнее и хранила бы, например, данные о кредитных картах или пароли пользователей, возможность изменения нашего кода делала бы владельца любого проекта беспомощным против хакеров.

Для решения этой проблемы нам необходимо ограничить доступ к переменной и функции.

## Глобальная область видимости

До настоящего времени мы писали код в _глобальной области видимости_ - месте, в котором можно изменить любую функцию или переменную и на них не накладывается никаких ограничений.

Все функции имеют доступ к переменным и функциям глобальной области видимости

```javascript
// эта информация доступна любой функции в программе
let secret = "Ленин - гриб!";

function showSecret() {
  // любая функция имеет доступ к глобальной области видимости
  console.log(secret); // выдаст содержимое secret
}

console.log(secret); // тоже выдаст содержимое uglyNews
showSecret();
```

## Функциональная область видимости

_Функциональная область видимости_ ограничивает доступность переменных и функций _телом функции_. Иными словами, всё, что находится в функции, должно остаться только в ней.

Функция ограничивает доступ к своим переменным

```javascript
function keepSecret() {
  let secret = "Ленин - гриб!";
  console.log(secret); // Выведет «Ленин - гриб!»
}

// Выдаст ошибку «Can't find variable: secret»
console.log(secret);
```

## Границы областей видимости

Таким образом, переменные и функции, созданные в _функциональной области видимости_ _keepSecret_,
**доступны только в рамках созданной _keepSecret_**

[![scopes.png](https://i.postimg.cc/wM3p3ttw/scopes.png)](https://postimg.cc/p5N76LJj)

Переменные и функции, созданные в _глобальной области видимости_, **доступны везде**.

## Использование функций

Один из способов решения проблемы с безопасностью - использование _функциональной области видимости_.

Создадим функцию init и сразу же её вызовем:

main.js

```javascript
function init() {
  let firstName = "Олег";
  function showGreeting(person) {
    console.log(`С днём рождения, ${person}!`);
  }

  showGreeting(firstName);
}

init();

console.log(firstName);
```

Результат вызова:

[![2018-12-02-0-56-55.png](https://i.postimg.cc/PqJwYdgR/2018-12-02-0-56-55.png)](https://postimg.cc/Lqd5MF6t)

Итого: мы получили сообщение с поздравлением и ошибку, которая возникла на последней строке из-за попытки обращения к переменной _firstName_, которая находится в _функциональной области видимости_ и доступна только функции _init_, но не глобальной переменной.

## Замыкания. Окружение

Предположим, что у нас есть некая, нами написанная функция _tick_, которая должна каждый раз при вызове выводить в консоль число на единицу больше (своеобразный таймер):

```javascript
function tick() {
  // какой-то код, который мы ещё напишем
}

tick(); // 1
tick(); // 2
tick(); // 3
```

**Задача**: напишите функцию _tick_.

## Уничтожение

Попробуем создать в _tick_ переменную и сразу же увеличить её на 1:

```javascript
function tick() {
  let start = 1;
  console.log(start++);
}

tick(); // 1
tick(); // 1
tick(); // 1
```

Почему это не работает? Дело в том, что _start_ создается и **уничтожается с каждым новым вызовом _tick_**.

## Переменные в глобальной области видимости

Но мы можем использовать _глобальную область видимости_!

```javascript
let start = 1;

function tick() {
  console.log(start++);
}

tick(); // 1
tick(); // 2
tick(); // 3
```

В таком случае _start_ **уничтожится только после того как посетитель закроет вкладку**.
Иными словами, переменные в _глобальной области видимости_ **не уничтожаются из памяти**.
Переменные _функциональной области видимости_ **доступны только на время выполнения функции**.

# Замыкания

## Что такое замыкание?

```javascript
let start = 1;

function tick() {
  console.log(start++);
}
```

*Замыкания* — это функция вместе со всеми внешними переменными, которые ей доступны. Другими словами, функция, определённая в _замыкании_, «запоминает» окружение, в котором она была создана.

В нашем случае замыканием является функция _tick_.

## Добавляем условие

Если нам потребуется создать функцию _tick10_, которая бы считала с 10, нам потребуется доработать программу:

```javascript
let start = 1;

function tick() {
  console.log(start++);
}

tick(); // 1
tick(); // 2
tick(); // 3

let start10 = 10;

function tick10() {
  console.log(start10++);
}

tick10(); // 10
tick10(); // 11
tick10(); // 12
```

Можно ли объединить этот код?

## Избавляемся от переменных в глобальной области видимости

Как и говорилось ранее, **_return_ может возвращать любое выражение**, в том числе и функцию.

Предположим, что у нас есть мифическая функция _createCounter_, которая должна работать так:

```javascript
function createCounter() {
  // какой-то код
}

let tick = createCounter(1), // начинаем считать с 1
  tick10 = createCounter(10); // начинаем считать с 10

tick(); // 1
tick(); // 2
tick(); // 3

tick10(); // 10
tick10(); // 11
tick10(); // 12
```

## Анализируем

Раз _tick_ и _tick10_ - функции, значит _createCounter_ должна возвращать функцию:

```javascript
function createCounter() {
  /*
		Именно эта функция сработает, когда мы будем вызывать tick или tick10.
		Иными словами, именно эта функция поместится в tick и tick10.
	*/
  return function () {
    // какой-то код
  };
}
```

В _createCounter_ мы передаём начальное значение счётчика:

```javascript
function createCounter(start = 0) {
  return function () {
    // какой-то код
  };
}
```

Как и в базовой версии _tick_, нам нужно использовать консоль и увеличение значения на один для работы функции:

```javascript
function createCounter(start = 0) {
  return function () {
    console.log(start++);
  };
}
```

Готово!

[![2018-12-02-13-24-54.png](https://i.postimg.cc/0NHPpdpp/2018-12-02-13-24-54.png)](https://postimg.cc/2qvsYW96)

## Замыкания. Пояснение (демо)

В нашем случае _замыканием_ является вложенная в _createCounter_ функция, которая использует аргумент _start_, находящийся в области видимости вне _createCounter_.

Как происходит поиск переменных и функций по областям видимости?

```javascript
function createCounter(start = 0) {
  return function () {
    console.log(start++);
  };
}

let tick = createCounter(1), // начинаем считать с 1
  tick10 = createCounter(10); // начинаем считать с 10

tick(); // 1
tick(); // 2
tick(); // 3

tick10(); // 10
tick10(); // 11
tick10(); // 12
```

## Поиск в областях видимости

Если в текущей области видимости какая-то переменная не была найдена, она ищется в **области видимости выше** (включая глобавльную).

```javascript
let x = 8;
function findX() {
  function stillFindX() {
    function whereIsX() {
      console.log(`X = ${x}`); // X = 8
    }
    whereIsX();
  }
  stillFindX();
}
findX();
```

## Остановка поиска

Поиск останавливается при нахождении переменной.

```javascript
console.log(`X = ${x}`); // X = 3;
function findX() {
  let x = 8;
  function stillFindX() {
    let x = 4; // тут поиск переменной x остановится
    function whereIsX() {
      console.log(`X = ${x}`); // X = 4
    }
  }
  stillFindX();

  console.log(`X = ${x}`); // X = 8;
}
findX();

console.log(`X = ${x}`); // X = 3;
```

Если переменная не найдена ни в одной области видимости, мы получим ошибку:

## Поиск в областях видимости

```javascript
function leninHistory() {
  let leninName = "Владимир";
  console.log(`Меня зовут ${leninName}, у меня нет предшественников`);
  function stalinHistory() {
    let stalinName = "Иосиф";

    console.log(
      `Меня зовут ${stalinName}, Имя моего предшественника: ${leninName}`
    );

    function medvedevHistory() {
      let medvedevName = "Дмитрий";

      console.log(
        `Меня зовут ${medvedevName}, Имена моих предшественников: ${stalinName}, ${leninName}`
      );
    }
    medvedevHistory();
  }
  // не забываем выполнить объявленную функцию
  stalinHistory();
}

leninHistory();
```

[![lsm.png](https://i.postimg.cc/t4V6gkQZ/lsm.png)](https://postimg.cc/VJmvGjNm)

Иллюстрация областей видимости:

[![lsmg.png](https://i.postimg.cc/pdysPTDV/lsmg.png)](https://postimg.cc/zLZCjqt4)

## Изменения в областях видимости

Будьте аккуратны, используя замыкания:

```javascript
let firstName = "Олег";
function changeName() {
  firstName = "Иван";
}

console.log(firstName); // Олег
changeName();
console.log(firstName); // Иван
```

Для этого не забывайте ставить let:

```javascript
let firstName = "Олег";
function changeName() {
  // !!!
  let firstName = "Иван";
}

console.log(firstName); // Олег
changeName();
console.log(firstName); // Олег
```

## Чему мы научились?

1. Познакомились с исключениями: узнали как генерировать и перехватывать исключения
2. Изучили новые интересные методы для работы с консолью
3. Узнали про области видимости
4. Познакомились с концепцией замыканий

---

# Домашнее задание

Давайте посмотрим ваше [домашнее задание](https://github.com/netology-code/bjs-homeworks/tree/master/3.1-exceptions-closure)

- Вопросы по домашней работе задаем в группе Slack!
- Задачи можно сдавать по частям.
- Зачет по домашней работе проставляется после того, как приняты все.

---

## Спасибо за внимание! Время задавать вопросы 🙂
