# Работа с массивами

# План занятия

1. Вспомним, что мы знаем о массивах
2. Константы и массивы, мутабельность и иммутабельность
3. Поиск в массиве
4. Расширенный поиск в массиве
5. Методы массива

## Какие из методов вы помните?

Вы уже знакомы с массивами и некоторыми методами.
Работать с массивами приходится постоянно, поэтому со временем большинство методов вы будете знать наизусть. Проверим себя:

```js
const arr = ["Ann", "Helen", "Fox"];
arr.push("Richard");
arr.push(123);
arr.push("Jane");
arr.pop();
arr.shift();
arr.unshift("Olga");
console.log(arr);
let arr2 = arr.slice(1, 3);
console.log(arr2);

arr.splice(1, 2, "some val");
console.log(arr);

let arr3 = arr.concat(["learn", "js"]);
console.log(arr3);
```

Каков будет результат?

## Ответы

```js
["Olga", "Helen", "Fox", "Richard", 123][("Helen", "Fox")][
  ("Olga", "some val", "Richard", 123)
][("Olga", "some val", "Richard", 123, "learn", "js")];
```

## Вспомним константы

Вопрос:
Что будет выведено в консоль при выполнении этого блока кода?

```javascript
const numbers = [1, 2, 3];
numbers.shift();
numbers.pop();
console.log(numbers);
numbers = [3, 2, 6]; // Ошибка
```

Как видим `shift` и `pop` отработали и внесли изменения в массив.

Изменять массивы можно. Запрещено только присваивание.

Мы выяснили, что массив сохраненный в константе можно изменять с помощью его методов.

---

### Мутабельность и иммутабильность

Объекты, имеющие методы, которые позволяют менять сам объект, или свойства, которые можно менять напрямую, являются изменяемыми, мутабельными (от слова _мутация_, _мутант_).

Запомните еще раз, оператор `const` не делает объекты и массивы неизменными, иммутабильными. (Для этого есть метод `Object.freeze()` . `const` только ограничивает операции присваивания в переменную.

### Массив это объект

Кстати, массив это объект, в этом легко убедиться на этом примере кода:

```javascript
console.log(typeof []); // object
```

### Проверка на массив

У нас есть функция, которая выводит в консоль содержимое массива. Что будет если в нее передать не массив?

```javascript
function logArray(arr) {
  console.log(`Массив размером ${arr.length}`);
  for (let item of arr) {
    console.log(`${item} (${typeof item})`);
  }
}

logArray(12);
```

```js
// Массив размером undefined
// TypeError: arr is not iterable
```

Как мы можем проверить аргумент и защититься от неправильного использования функции?

## Проверка на массив `Array.isArray`

Ранее мы уже выяснили, что `typeof` для массива возвращает `object`. Поэтому нужно другое решение. Для этого можно использовать функцию `Array.isArray`:

```js
function checkArr(arr) {
  if (!Array.isArray(arr)) {
    console.log(`Массив размером ${arr.length}: [`);
  } else {
    console.log("Это не массив");
  }
}
```

Такого же результата можно добиться используя

```js
if (arr instanceof Array) {
  console.log("Это массив");
}
```

## Преобразование в массив с помощью `Array.from`

Функция `Array.from`, позволяет создавать массивы из итерируемых и массивоподобных объектов:

```javascript
const str = "Не массив!";

const simbols = Array.from(str);

console.log(simbols);
```

Итерируемый объект — объект, у которого есть итератор, изучите их в продвинутой версии курса. Массивоподобный объект — объект, у которого есть свойство `lenght` и числовые ключи.

### Функция объявленная без аргументов

Допустим, вы создали функцию без аргументов:

```javascript
function logArgs() {}

logArgs(1, 2, 3);
```

Как в теле функции обратиться к аргументам, переданным при вызове функции?

### Массивоподобный объект `arguments`

Внутри каждой функции доступна переменная `arguments`, которая предоставляет альтернативный доступ ко всем переданным в функцию аргументам:

```javascript
function logArgs() {
  console.log(arguments); // Arguments[1,2,3]
  console.log(arguments.lenght); // 3
  console.log(Array.isArray(arguments)); // false
  console.log(arguments.join(", ")); // Uncaught TypeError: arguments.join is not a function
}

logArgs(1, 2, 3);
```

Мы видим, что `arguments` не является массивом, хотя и очень на него похож. И у него нет метода `join`.

### Преобразуем `arguments` в массив

Вот тут нам и поможет функция `Array.from`, чтобы получить полноценный массив:

```javascript
function logArgs() {
  console.log(Array.from(arguments).join(", "));
}

logArgs(1, 2, 3); // 1, 2, 3
```

Преобразовывать объект `arguments` в массив имеет смысл, только если нам нужны возможности массива, которых в объекте нет.

# Итерация по массиву

Любая задача работы с массивом (поиск, преобразования, фильтрация) может быть решена итерацией по массиву. В этом смысле этот способ универсальный.

## Способы итерации

Уже знакомый нам универсальный цикл for

```js
const arr = [30, 10, 50, 1, 31, 178, 15];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

Метод forEach:

```js
arr.forEach((item, idx, arr) => console.log(item));
```

Тот же результат с помощью `for...of`

```js
for (const item of arr) {
  console.log(item);
}
```

Сравнение скорости можно посмотреть здесь (https://jsbench.me/yhkngi7lx9/1)
Метод `forEach` самый быстрый. Также можно воспользоваться циклом while.

# Поиск в массиве

## Индекс искомого элемента

Допустим, у нас есть массив имен, и мы хотим выяснить, под каким индексом в массиве хранится имя `Иван`:

```javascript
const names = ["Денис", "Егор", "Петр", "Иван", "Олег"];
```

Вариант с перебором в цикле `for-of` не подходит, потому что там нет индекса. Остаются `for-in` или `for`.

Но есть способ лучше.

## Метод массива `indexOf`

У массива есть метод `indexOf`, который строго сравнивает аргумент с каждым элементом массива и возвращает индекс первого элемента, сравнение с которым вернет истину:

```javascript
const names = ["Денис", "Егор", "Петр", "Иван", "Олег"];

console.log(names.indexOf("Иван")); // 3
console.log(names.indexOf("Егор")); // 1
console.log(names.indexOf("Маша")); // -1
```

Обратите внимание, что возвращает индекс, а не номер. Индексы начинаются с 0.
Метод `indexOf` вернет `-1`, если искомого элемента нет.

### Частая ошибка с `indexOf`

Создадим функцию, которая добавляет элемент в массив только если его там еще нет:

```javascript
function pushOnce(arr, item) {
  if (!arr.indexOf(item)) {
    arr.push(item);
  }
}

const uniqNumbers = [];
pushOnce(uniqNumbers, 1);
pushOnce(uniqNumbers, 2);
pushOnce(uniqNumbers, 2);
pushOnce(uniqNumbers, 1);

console.log(uniqNumbers); // []
```

Массив пуст, хотя там должно быть два элемента. Почему?

### Правильная проверка наличия

Когда элемент не найден, `indexOf` возвращает `-1`, именно это и нужно проверять в функции `pushOnce`:

```javascript
function pushOnce(arr, item) {
  if (arr.indexOf(item) === -1) {
    arr.push(item);
  }
}

const uniqNumbers = [];
pushOnce(uniqNumbers, 1);
pushOnce(uniqNumbers, 2);
pushOnce(uniqNumbers, 2);
pushOnce(uniqNumbers, 1);

console.log(uniqNumbers); // [1,2]
```

Теперь функция работает, как задумывалось.

### Лучшая проверка наличия

Метод `indexOf` часто используется в условиях, и многие часто допускают ошибку проверки. Чтобы полностью исключить вероятность такой ошибки, используйте метод `includes`. Он идентичен методу `indexOf`, только вместо индекса он возвращает true, если искомый элемент есть в массиве, иначе возвращает false.

Перепишем функцию `pushOnce`, используя более подходящий метод:

```javascript
function pushOnce(arr, item) {
  if (!arr.includes(item)) {
    arr.push(item);
  }
}

let numbers = [];
pushOnce(numbers, 1);
pushOnce(numbers, 2);
pushOnce(numbers, 2);
pushOnce(numbers, 3);
console.log(numbers); // [1, 2, 3]
```

### Если искомых элементов несколько

Если в массиве искомых элементов не один, а несколько, какой индекс вернёт метод `indexOf`:

```javascript
const numbers = [1, 1, 2, 2, 2, 3, 3];
console.log(numbers.indexOf(2)); // 2
```

Так как перебор элементов ведется с первого, и при первом же соответствии поиск прекращается, то мы получим индекс первого элемента соответствующего искомому.

### Поиск справа налево

Если в массиве искомых элементов не один, и нам нужен индекс последнего из них, можем воспользоваться методом `lastIndexOf`:

```javascript
const numbers = [1, 1, 2, 2, 2, 3, 3];
console.log(numbers.lastIndexOf(2)); // 4
```

Метод `lastIndexOf` полностью идентичен методу `indexOf`, но возвращает позицию последнего элемента

# Расширенный поиск в массиве

## Поиск индекса элемента в более свободной форме

Что если мы хотим найти индекс первого четного элемента в массиве?

```javascript
const numbers = [127, 41, 454, 296, 489];
```

Метод `indexOf` тут явно не поможет, потому что мы не знаем, какое это будет число. Знаем только, что оно будет четное.
Попробуем перебрать массив в цикле. Как только мы нашли четное число, сохраняем его в переменную и прерываем цикл.

```javascript
let evenIndex = -1;
for (let i in numbers) {
  const number = numbers[i];
  if (number % 2 === 0) {
    evenIndex = i;
    break;
  }
}

console.log(evenIndex); // 2
```

## Императивность и декларативность

Императивный код — полностью описывает каждое необходимое действие, чтобы достигнуть поставленной задачи.

Декларативный код — описывает задачу и ожидаемый результат. Как должен быть достигнут ожидаемый результат, может быть вообще не описано.

> Минус императивного кода — за командами не всегда ясна решаемая задача.
> Минус декларативного кода — непонятно, как достигается поставленный результат.

Декларативный код легче читать, поэтому всегда стремитесь не просто решить задачу, но и сделать решение более декларативным.

В JavaScript сделать код более декларативным помогают создаваемые программистом функции и использование стандартных возможностей языка. Часто использование своего решения вместо использования средства языка называют «велосипедом».

## Метод `findIndex`

В JavaScript у массива есть метод `findIndex`, который позволяет найти индекс искомого элемента, описав условие функцией.

Метод принимает в качестве аргумента функцию проверки, применяет её к каждому элементу массива до тех пор, пока функция проверки не вернет истину и возвращает текущий индекс элемента.

`findIndex` является функцией высшего порядка. Кроме того, что вместо значения искомого элемента он принимает функцию проверки, в остальном он идентичен методу `indexOf`.

### Избавляемся от велосипедов

Функция проверки должна принимать элемент массива и возвращать истину или ложь, поэтому наша функция `isEven` отлично подойдет в качестве функции проверки:

```javascript
const numbers = [127, 41, 454, 296, 489];
const numbersWithoutEven = [127, 41, 365, 7, 489];

function isEven(number) {
  return number % 2 === 0;
}

console.log(numbers.findIndex(isEven)); // 2
console.log(numbersWithoutEven.findIndex(isEven)); // -1
```

Обратите внимание: несмотря на то, что четных элементов в массиве несколько, возвращается индекс первого.

> Метода `findLastIndex` у массивов нет. Потому что всегда можно воспользоваться методом `reverse`, который переставляет элементы массива в обратном порядке.

### А что если хотим найти само четное число

Воспользуемся методом `find`, который очень похож на `findIndex`, только возвращает не индекс, а сам элемент:

```javascript
const numbers = [127, 41, 454, 296, 489];
const numbersWithoutEven = [127, 41, 365, 7, 489];

function isEven(number) {
  return number % 2 === 0;
}

console.log(numbers.find(isEven)); // 454
console.log(numbersWithoutEven.find(isEven)); // undefined
```

### Частая ошибка с `find`

```javascript
const numbers = [127, 0, 41, 365, 7, 489];

function isEven(number) {
  return number % 2 === 0;
}

if (!numbers.find(isEven)) {
  // Метод `find` на самом деле нашел четное число 0, но !0 === true
  console.log("В массиве все числа нечетные");
}

if (numbers.find(isEven) === undefined) {
  // Правильная проверка
  console.log("В массиве все числа нечетные");
}
```

## «Хотя бы один» - some

У массива есть специальный метод `some` (_хотя бы один_ в переводе с английского). Он очень похож на `find`, но возвращает не сам элемент, а истину, если есть хотя бы один элемент удовлетворяющий условию. Чем также похож на `includes`.

Используем его для нашего примера:

```javascript
const numbers = [127, 0, 41, 365, 7, 489];

function isEven(number) {
  return number % 2 === 0;
}

console.log(numbers.some(isEven)); // true
```

## «Каждый» - every

Используем метод `every` (_каждый_ в переводе с английского), который похож на `some`, но возвращает истину только если все элементы массива удовлетворяют требованиям:

```javascript
function isEven(number) {
  return number % 2 === 0;
}

function isEvenArray(arr) {
  return arr.every(isEven);
}

console.log(isEvenArray([24, 42, 176])); // true
console.log(isEvenArray([24, 41, 176])); // false
```

### «Хотя бы один» и «Каждый»

Очень часто поиск элементов в массиве сводится к двум простым проверкам:

- есть ли в массиве хотя бы один элемент, соответствующий требованиям,
- соответствуют ли все элементы массива требованиям.

Для решения подобных задач можно использовать `find` или `findIndex`. Но гораздо удобнее использовать специальные методы `some` и `every`. Их работа похожа на `find`, но они сразу возвращают истину или лож, что проще использовать в `if`.

## Поиск в массиве объектов

Допустим, у нас есть массив сотрудников:

```javascript
const employees = [
  { name: "Мария", department: "IT", salary: 75000 },
  { name: "Иван", department: "Продажи", salary: 55000 },
  { name: "Николай", department: "IT", salary: 92000 },
  { name: "Мария", department: "Маркетинг", salary: 35000 },
];
```

Давайте решим следующие простые задачи:

1. Найдем Марию из отдела IT.
2. Выясним, есть ли у кого-то зарплата более 90000.
3. Проверим, все ли получают более 50000.

### Решение

Работа с массивом объектов ничем не отличается от работы с массивом чисел, просто в функции проверки мы будем работать с объектом, а не числом. Для решения задач нам потребуются:

1. `find`
2. `some`
3. `every`

```javascript
const task1 = employees.find(employee =>
  employee.name === 'Мария' && employee.department === 'IT';
);

const task2 = employees.some(employee =>
  employee.salary > 90000;
);

const task3 = employees.every(employee =>
  employee.salary > 50000;
);
```

## Найти все элементы, удовлетворяющие условию

> Что если нам потребуется найти всех сотрудников по имени `Мария`?

## Метод `filter`

Метод `filter` очень похож на `find`, только в отличии от него **всегда возвращает новый массив**, в который помещает все элементы исходного массива, удовлетворяющие требованиям заданным в функции проверки.

Грубо говоря, каждый элемент, для которого функция проверки вернет истину, будет добавлен в массив. Если таких элементов нет, то массив будет пустой.

### Находим всех Марий

```javascript
const maries = employees.filter((employee) => employee.name === "Мария");
console.log(maries);
// [
//   { name: 'Мария', department: 'IT', salary: 75000 },
//   { name: 'Мария', department: 'Маркетинг', salary: 35000 },
// ]
```

### Зарплата меньше 90000 не в IT

```javascript
const noItBelow90K = employees.filter(
  (employee) => employee.department !== "IT" && employee.salary < 90000
);
console.log(noItBelow90K);
// [
//   { name: 'Иван', department: 'Продажи', salary: 55000 },
//   { name: 'Мария', department: 'Маркетинг', salary: 35000 },
// ]
```

### Filter всегда возвращает массив

Даже если ничего не найдено или найден один элемент:

```javascript
const over90K = employees.filter((employee) => employee.salary > 90000);

console.log(over90K);
// [ { name: 'Николай', department: 'IT', salary: 92000 } ]

const noItOver90K = employees.filter(
  (employee) => employee.department !== "IT" && employee.salary > 90000
);

console.log(noItOver90K); // []
```

### Проверка на понимание `filter`

Вопрос: Что будет выведено на консоль?
Пример 1:

```javascript
console.log([1, 2, 3, 4].filter((item) => true));
```

Пример 2:

```javascript
console.log([1, 2, 3, 4].filter((item) => item - 2));
```

### Проверка на понимание `filter`

Пример 1. Так как функция проверки всегда возвращает истину, получим полную копию массива:

```js
// [ 1, 2, 3, 4 ]
```

Пример 2. Так как `filter` ждет от функции истину или ложь, а функция проверки возвращает числа, то числа приводятся к булевому значению.
Для элемента `2` функция проверки вернет `0`, что будет приведено ко лжи, остальные — к истине:

```js
[1, 3, 4];
```

# Преобразование массива

## Создание нового массива

Допустим, у нас есть массив, который содержит интервалы времени в секундах:

```javascript
const timeIntervals = [1800, 3600, 86400];
```

Нам для дальнейших расчетов нужно перевести эти интервалы из секунд в часы.

## Используем цикл

Переберем все интервалы исходного массива, переведем каждый в часы и поместим в новый массив:

```javascript
const timeIntervals = [1800, 3600, 86400];
const secondsInHour = 3600;

function secondsToHours(sec) {
  return sec / secondsInHour;
}

const timeIntervalsInHours = [];
for (const interval of timeIntervals) {
  const hours = secondsToHours(interval);
  timeIntervalsInHours.push(hours);
}
console.log(timeIntervalsInHours); // [ 0.5, 1, 24 ]
```

В JavaScript есть возможность сделать еще лучше.

## Метод массива `map`

> Создает новый массив, поместив в него результат вызова переданной функции для каждого элемента исходного массива.

Метод `map` — это функция высшего порядка, так как принимает функцию первым аргументом. Именно эта переданная в `map` функция будет вызвана для каждого элемента массива. Назовем её преобразователем.

### Преобразуем интервалы с помощью `map`

Метод `map` принимает функцию, создает и возвращает новый массив:

```javascript
const timeIntervals = [1800, 3600, 86400];
const secondsInHour = 3600;

const timeIntervalsInHours = timeIntervals.map((sec) => sec / secondsInHour);

console.log(timeIntervalsInHours); // [ 0.5, 1, 24 ]
```

Если прочитать код решения и перевести на русский, то будет похоже на

> преобразовать `timeIntervals` с помощью функции преобразователя и поместить результат в `timeIntervalsInHours`.

### Особенности использования `map`

При использовании метода массива `map` нужно обязательно учитывать ряд важных особенностей:

1. размер преобразованного массива всегда равен размеру исходного массива;
1. игнорирование результата метода `map` хоть и не является ошибкой, но обычно указывает на неправильное использование этого метода.

Разберём на примерах.

## Размер массива равен исходному

Попробуем возвести в квадрат только четные числа, а нечетные проигнорировать:

```javascript
const numbers = [1, 2, 3, 4, 5];

const sqEven = numbers.map(function (number) {
  if (number % 2 === 0) {
    return number * number;
  }
});

console.log(sqEven); // [ undefined, 4, undefined, 16, undefined ]
```

В JavaScript функция всегда возвращает результат, даже если во второй ветке нет `return`. Поэтому вместо нечетных чисел у нас `undefined`.

Используйте `map` совместно с `filter` для решения этой задачи.

### Квадраты четных чисел (демо)

Просто откинем `undefined` после, собрав вызовы `map` и `filter` в цепочку:

```javascript=
const numbers = [1, 2, 3, 4, 5];

const sqEven = numbers
  .map(function (number) {
    if (number % 2 === 0) {
      return number * number;
    }
  })
  .filter(item => item !== undefined);

console.log(sqEven);// [ 4, 16 ]
```

### Порядок имеет значение

А что если сначала отбросить нечетные числа а потом уже возвести полученный массив в квадрат:

```javascript
const numbers = [1, 2, 3, 4, 5];

const sqEven = numbers
  .filter((number) => number % 2 === 0)
  .map((number) => number * number);

console.log(sqEven); // [ 4, 16 ]
```

Результат тот же, но посмотрите как решение стало выглядеть проще, логичнее и декларативнее. Его можно читать как простой текст.

## Игнорирование результата

Типичный пример неправильного использования `map`:

```javascript
[1, 2, 3, 4, 5].map((item) => console.log(item));
```

Видно, что массив преобразуется с помощью функции-стрелки, но результат нам не важен. Потому что в данном случае мы используем `map` для простого перебора. Правильнее это переписать с помощью метода `forEach` или цикла `for-of`:

```javascript
[1, 2, 3, 4, 5].forEach((item) => console.log(item));
```

## Клонирование массива

Копирование (клонирование) массива весьма частая задача, которая может быть решена несколькими способами:

```js
const arr = ["Hello", "new", "world!"];
const clone1 = arr.slice();
const clone2 = [...arr];

const clone3 = [];
for (let i = 0; i < arr.length; i++) clone3.push(arr[i]);

let clone4 = arr.map((item) => item); //Как работает

//Если массив содержит вложенные массивы|объекты, наиболее удобный способ
let clone5 = JSON.parse(JSON.stringify(arr));
```

## Сортировка массива

Метод `sort` массива является мутабельными и изменяет исходный массив:

```js
const arr = ["Boris", "Cesar", "Ann"];
arr.sort(); // arr === ["Ann","Boris", "Cesar"];
```

Метод `sort` допускает агрумент - функцию сортировки:

```js
const myarr = [25, 8, 7, 41]
myarr.sort((a,b) => (a — b)); // Передаём внутрь стрелочную функцию.
// А как бы это выглядело с обычной функцией?
// Как отсортировать в обратном порядке?
// Как отсортировать немутабельно?
```

## Ответ

```js
const myarr= [25, 8, 7, 41];
const newArr = myarr.slice
myarr.sort(function(a,b) { return (b — a) });
// Иммутабельно. В обратном порядке.
// Обычная функция в качестве функции сортировки
```

## Универсальный метод reduce

Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение, которое в свою очередь может быть массивом. В этом смысле он универсален:

```js
// arr.reduce(reducer, initialAcc)
const arr = [10, 20, 15, 35, 5, 45, 60];
arr.reduce((acc, item, idx, arr) => {
  // Будет ровно arr.length шагов. На каждом шаге
  // item - элемент
  // idx - индекс элемента массива
  // arr - исходный массив
  // acc - аккумулятор, он же результат

  return; // в acc для следующего шага будет записано то, что в return;
}, initialAcc);
//Если initialAcc не передан, то берется первый элемент массива
```

## Пример

Подсчитаем количество четных элементов массива.

```js
const arr = [10, 20, 15, 35, 5, 45, 60];

const result = arr.reduce((acc, item, idx, arr) => {
  let newAcc = acc;
  if (item % 2 === 0) {
    newAcc++;
  }

  return newAcc;
}, 0); // начальное значение счётчика 0
```

## Пример

Подсчитаем среднее арифметическое:

```js
const numbers = [10, 20, 15, 35, 5, 45, 60];

const average = numbers.reduce((acc, item, idx, arr) => {
  acc += item;
  if (idx === arr.length - 1) {
    return acc / arr.length;
  } else {
    return acc;
  }
});

console.log(average);
```

## О методах для работы со строками

Часть методов для работы с массивами аналогично работают со строками:

- concat
- includes
- indexOf
- slice

# Чему мы научились?

1. Константы и массивы, мутабельность и иммутабельность
2. Поиск в массиве
3. Функции высшего порядка
4. Расширенный поиск в массиве
5. Методы массива

# Домашнее задание

Давайте посмотрим ваше [домашнее задание](https://github.com/netology-code/bjs-homeworks/tree/master/3.2-array-proto-hocs)

- Вопросы по домашней работе задаем в группе Slack!
- Задачи можно сдавать по частям.
- Зачет по домашней работе проставляется после того, как приняты все 3 задачи.

---

# Спасибо за внимание! Время задавать вопросы 🙂
