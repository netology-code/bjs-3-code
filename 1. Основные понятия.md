# 1. Синтаксис js

## План занятия

1. Работа с переменными
2. Операторы унарные, бинарные и тернарные
3. Условные конструкции, массивы и циклы
4. Доступ по значению и по ссылке
5. Продвинутая работа с числами
6. Продвинутая работа со строками
7. Типы null и undefined
8. Преобразование типов

---

# Вспомним то, что мы уже знаем

## Несколько вопросов на повторение

Ответьте на следующие вопросы:

- Что представляет из себя переменная, на ваш взгляд как ей объявить?
- Какие типы данных мы уже знаем?
- Что представляет собой функция?
- Что представляет из себя массив?
- Что представляет из себя объект?
- Можно ли объявить две переменные с одинаковым именем?

---

## Объявление и присваивание значения переменным. Типы данных

К данному моменту мы умеем объявлять переменные с помощью `let` и `const`
Нам знакомы типы данных:

- число (number)
- строка (string)
- булев тип (boolean)
- объект

Еще мы знакомы с массивами, которые также являются объектами (как и многое другое в js)

## Проверим

Что делает каждая строчка кода? Будут ли ошибки?

```javascript
let name
name = "Ann"
let age = 17
let age = 20
let study = true
study = false
const country
country = "Russia"
const gender = "female"
gender = "male"
var city = "Moscow"
```

---

## Ответы

```javascript
let name // Объявили
name = "Ann" // Инициализировали (строка)
let age = 17 // Объявили и инициализировали (число)
let age = 20 // Ошибка: нельзя объявить 2 переменных с одним именем
let study = true // (булево значение)
study = false // Присвоили другое значение
const country // Ошибка: нельзя объявить константу без значения
country = "Russia"
const gender = "female" // Правильное объявление констант
gender = "male" //Ошибка, нельзя присваивать новые значения константам
var city = "Владимир" // Устаревший способ объявления(подробнее в advanced)
```

---

## Константы

Константы накладывают ограничения **только** на присваивание значения, то есть оператор `=` и все производные (`+=`, `-=`, `*=` и так далее).

```javascript
const age = 21
age++
console.log(age)
// Ошибка, изменять константы нельзя
// TypeError: Assignment to constant variable.

const friends = ["Маша, Таня, Оля, Вика"]
friends.push("Константин")
console.log(friends) // ['Маша, Таня, Оля, Вика, Константин'];

const info = {
  city: "Moscow",
  age: 31,
}
info.gender = "male"
```

---

## Константа запрещает только присваивание

Константы запрещают только присваивание в переменную, и любые другие операции, которые основаны на присваивании (`+=`, `-=`, `%=`, `++`, `--` и др.), даже если это массив:

```javascript
const numbers = [1, 2, 3]
numbers = [4, 5, 6] // Uncaught TypeError: Assignment to constant variable.
```

---

## Требования к именам и правила

- Имя может состоять из букв, цифр, символов `$` и `_`.
- Первый символ не должен быть цифрой
- Регистр символов имеет значение. `time` `Time` и `TIME` — разные переменные.
- Зарезервированные ключевые слова нельзя использовать в качестве имени переменной. Например, мы не можем создать переменную c именем let или const.
- Используйте английский язык при выборе имени переменной или константы. Никакого транслита.
- Используйте `нижнийВерблюжийРегистр` (`lowerCamelCase`) для переменных, название которых состоит из нескольких слов. В нижнем верблюжьем регистре первое слово пишется с маленькой буквы.
- **Самое главное правило** : имя переменной должно четко отражать информацию, которая хранится в переменной и быть понятным не только автору кода.

Помимо соглашения camelCase также существуют kebab-case, snake-case и другие, но в рамках данного курса мы будем использовать camelСase.

---

# Операторы и операнды

---

## Вспомним прошлые занятия

Ответьте на следующие вопросы:

- Какие операторы вы помните?

---

## Оператор и операнд

**Оператор** — это команда, которая на письме выглядит как простой символ. С помощью операторов выполняются некоторые действия над данными.
Данные, расположенные справа и слева от оператора называются **операндами**.

Операторы бывают:

- Унарные (англ. unary);
- Бинарные (англ. binary);
- Тернарные (англ. ternary).

На следующих слайдах рассмотрим каждый тип подробнее.

---

## Операторы

**Унарные** оперируют только левым или правым операндом

```javascript
let temp = -10 // берет отрицательное число
let result = !false // меняет true на false и обратно
let age = +"10" // преобразует к числу
```

**Бинарные** оперируют левым и правым операндами.

- Оператор присвоения `=`, `+=`, `-=`
- Оператор сложения (либо конкатенации строк) `+`
- Оператор деления `/`
- Оператор умножения `*`
- Оператор вычитания `-`
- Оператор взятия остатка `%`
- Операторы сравнения `>`, `<`,`>=`,`<=`,`!==`, `===`
  (строки сравниваются побуквенно)

Нестрогое сравнение `==`, `!=` использовать крайне не рекомендуется, так как это ведет к множеству проблем (происходит преобразование типов). Разве что, вы точно знаете, что делаете. Таблица результатов нестрогого сравнения
(https://dorey.github.io/JavaScript-Equality-Table/)

---

## Парадоксы при нестрогом сравнении

```js
[0]==0   //true
0==[]    //true
[]==''   //true
''==[0]  //false
```

Вывод - во первых большая таблица для запоминания, а во вторых большой потенциал для ошибки.

## Тернарный оператор

Иногда нужно в зависимости от условия присвоить переменную.

```
условие ? значение1 : значение2
```

Проверяется условие, затем если оно верно – возвращается значение1, если неверно – значение2, например:

```javascript
let age = 18
access = age > 14 ? true : false
greeting = age >= 18 ? "Здравствуйте" : "Привет"
```

_В первом случае можно было бы обойтись и без оператора '?', так как сравнение само по себе уже возвращает true/false:_

Вопросительный знак – единственный оператор, у которого есть аж три аргумента, в то время как у обычных операторов их один-два. Поэтому его называют "тернарный оператор".

---

## Строковые шаблоны (template literals)

Шаблоны — это строки, в которые можно подставить значения переменных.
Для этого используется новый тип кавычек и особый синтаксис:
`${имяПеременной}` .

**Обратите внимание, что для шаблонов используются апострофы ==\` \`==, а не одинарные кавычки ==' '==** (шифт тильда)

Допустим у нас есть задача рассчитать, через какое время встретятся поезда, следующие на встречу друг другу:

```javascript
let train1Speed = 112
let train2Speed = 73
let distance = 1056
let time = distance / (trainMscSpeed + trainSmrSpeed)
let distanceFromMsc = trainMscSpeed * time
console.log(`Поезда встретятся ${time} через часов`)
console.log(`Встреча произойдет в ${distanceFromMsc} км от Москвы`)
```

---

## Логические операторы

## Оператор || (ИЛИ)

Оператор вам уже знаком

```javascript
let milk = 60
let bread = 30
let fruits = 80
console.log(milk + bread < 70 || fruits <= 100)
```

Логическое ИЛИ в классическом программировании работает следующим образом: "если хотя бы один из аргументов true, то возвращает true, иначе – false".

## Короткий цикл вычислений

JavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый «короткий цикл вычисления».

Допустим, вычисляются несколько ИЛИ подряд: a || b || c || .... Если первый аргумент – true, то результат заведомо будет true (хотя бы одно из значений – true), и остальные значения игнорируются.

```javascript
console.log(15 > 100 || "some value")
```

**Если все значения «ложные», то || возвратит последнее из них.**

Ложных значений всего 6 и они также доступны в таблице (https://dorey.github.io/JavaScript-Equality-Table/)

## Оператор && (И)

Оператор И вам уже знаком.

Интересно, что к И применим тот же принцип «короткого цикла вычислений», но немного по-другому, чем к ИЛИ.

Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.

```javascript
console.log(true && "write me")
console.log(false && 10)
```

## Оператор !(НЕ)

Оператор НЕ – самый простой. Он получает один аргумент. Синтаксис:

```javascript
let result = !value
```

1. Сначала приводит аргумент к логическому типу true/false.
2. Затем возвращает противоположное значение.

```javascript
console.log(!true) // false
console.log(!0) // true
```

**В частности, двойное НЕ используют для преобразования значений к логическому типу**

```javascript
console.log(!!{ name: "Vasia", age: 36 }) // true
```

Как происходит приведение к `true/false` можно посмотреть в той же таблице (https://dorey.github.io/JavaScript-Equality-Table/)

# Условные конструкции и циклы

## Условные конструкции

Вам уже знакома условная конструкция

```js
let age = +prompt("Сколько вам лет?")
// prompt() показывает окно для ввода и возвращает строку
// + преобразует к числу

if (age >= 18) {
  console.log("Доступ разрешен")
} else if (age > 21) {
  console.log("Вам даже в штатах можно все!")
} else if (age > 60) {
  console.log("Пенсия... хотя может быть и нет :)")
} else {
  console.log("Маловат еще")
}
```

Кто может объяснить, что происходит?

---

## Конструкция switch

Конструкция switch заменяет собой сразу несколько if.

Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

## Синтаксис switch

```javascript
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    break;
  case 'value2':  // if (x === 'value2')
    ...
    break;
  default:
    ...
    break;
}
```

- Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
- Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
- Если ни один case не совпал – выполняется (если есть) вариант default.

## Группировка case (демо)

Несколько значений case можно группировать.

В примере ниже case 3 и case 5 выполняют один и тот же код:

```javascript
let a = 5 + 7

switch (a) {
  case 12:
    alert("Верно!")
    break

  case 11:
  case 13:
    alert("Неверно!")
    alert("Немного ошиблись, бывает.")
    break

  default:
    alert("Странный результат, очень странный")
}
```

## Циклы

Вспомним уже знакомые нам циклы `for` и `while`

```js
let result = 0,
  i = 1
while (i < 5) {
  result += i
  i++
}
console.log(result) // Что выведет?
```

```js
let names = ["Sasha", "Katya", "Vika", "Maria"]
for (let i = 0; i < names.length; i = i + 2) {
  console.log(names[i]) // Что будет выведено?
}
```

## Прерывание цикла: break (новое)

Выйти из цикла можно не только при проверке условия но и вообще в любой момент. Эту возможность обеспечивает директива break.

_Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале-конце цикла, а посередине._

Например задача, найти первое четное число:

```js
let numbers = [1, 23, 33, 46, 25, 13, 58]
for (let i = 0; i < numbers.length; i = i + 2) {
  if (numbers[i] % 2 === 0) {
    console.log("Первое найденное четное число равно: ", numbers[i])
    break
  }
}
```

## Следующая итерация continue (новое)

Директива continue прекращает выполнение текущей итерации цикла.

Она в некотором роде «младшая сестра» директивы break: прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось.

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

```js
let i = 0
let result = 0
while (i < 5) {
  i++
  if (i === 3) {
    continue
  }
  result += i
}
```

Суммируем числа от 0 до 5, пропуская 3.

# Доступ по значению и по ссылке (демо)

Вопрос, что будет выведено в результате выполнения кода?

```js
let a = 4
let b = a
b += 5
console.log(a, b) // (1)
// а так?
let c = { a: 1, b: "foo" }
let d = c
d.a = false
console.log(c, d) // (2)
```

---

## Данные по значению и по ссылке. Результат

![](https://sun9-63.userapi.com/c204528/v204528504/75029/Cm81XZzgerI.jpg)

## Данные по значению и по ссылке. Пояснение

![](https://sun9-27.userapi.com/c204528/v204528504/75045/B61mXW5CIEg.jpg)

# Числа

Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-2008).

```js
let a = 54
let b = 0xff // 255 в шестнадцатиричной системе
let c = 3e5 // в научной форме: 3 * 10^5 т.е. 300000
let d = 3e-5 // здесь 3 * 10^-5 0.00003
```

## Неточные вычисления

Какое значение переменной result после вычисления:

```js
let result = 0.1 + 0.2 == 0.3
```

> true или false?

## Неточные вычисления

Операции над числами могут привести к неожиданным результатам:

```js
alert(0.1 + 0.2) // 0.30000000000000004
alert(9999999999999999) // 10000000000000000
```

Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.

## Как избежать неточных вычислений?

Функция toFixed(digits) форматирует число, используя запись с фиксированной запятой.

> digits - количество цифр после десятичной запятой; может быть значением между 0 и 20 включительно, хотя реализации могут поддерживать и больший диапазон значений. Если аргумент опущен, он считается равным 0.

```js
let a = (9.699932).toFixed(3)
```

## Округление чисел

```js
Math.floor() // Округляет в меньшую сторону
Math.round() // Округляет к ближайшему целому
Math.ceil() // Округляет в большую сторону
Math.trunc() // Убирает дробную часть
```

## Пример

Что будет выведено на консоль?

```js
console.log(Math.floor(1.1)) // 1
console.log(Math.floor(1.9)) // 1

console.log(Math.round(3.1)) // 3
console.log(Math.round(3.9)) // 4

console.log(Math.ceil(3.1)) // 4
console.log(Math.ceil(3.9)) // 4

console.log(Math.ceil(-3.1)) // -3
console.log(Math.ceil(-3.9)) // -3
```

## Особенные числовые значения

> Какое значение мы получим, если попытаемся какое-либо число разделить на ноль?

## Значение Infinity

```js
console.log(1 / 0) // Infinity
```

> Это значение ведёт себя как математическая бесконечность; например, любое положительное число, умноженное на Infinity даёт Infinity, а любое число, делённое на Infinity, даёт 0.

## Особенные числовые значения NaN

Какое значение мы получим, если попытаемся строку умножить или разделить на число?

> Если мы попытаемся получить число из значения, которое ввели в поле для ввода, то не всегда у нас может получиться ожидаемое значение.

NaN является значением, представляющим не-число (Not-A-Number).

```js
console.log("десять" * 3) // NaN
```

> NaN Возникает, когда математические функции не могут вернуть значение (например, при вызове Math.sqrt(-1)) или когда функция считывания числа из строки не может это сделать, потому что в строке не число (parseInt('blabla')).

```js
console.log(typeof NaN) // "number"
console.log(NaN === NaN) // false
console.log(isNaN(NaN)) // true
```

# Строки

В JavaScript любые текстовые данные являются строками.
Строки создаются при помощи двойных или одинарных кавычек.

```js
let text = "это строка"
var anotherText = "еще одна строка"
var str = "012345"
```

## Шаблонные строки (повторение изученного)

В JavaScript строки можно составлять по шаблону, вставляя определенные значения непосредственно в строку.
Для этого необходимо воспользоваться косыми кавычками: `` `это шаблонная строка` ``

```js
let name = "Петр";
let job = 'Программист'
let result = `Привет, меня зовут ${name}, мне ${10+9} лет, я ${job}`);
```

## Специальные символы

Как решить проблему, если необходимо вставить символ, который отсутствует на клавиатуре или необходимо добавить кавычки?

## Специальные символы

| Символ | Описание                                      |
| ------ | --------------------------------------------- |
| \n     | Перевод на новую строку                       |
| \t     | Символ табуляции                              |
| \uNNNN | Любой юникод символ с шестнадцатеричным кодом |
| \\'    | Экранирование одинарной кавычки               |
| \\"    | Экранирование двойной кавычки                 |

## Специальные символы

```js
console.log("I'm a JavaScript programmer") // I'm a JavaScript programmer
console.log("\u262D \u262A \u2766 \u2713 \u262F \u2328") // ☭ ☪ ❦ ✓ ☯ ⌨
```

## Доступ к символам

Строка является массивом символов, следовательно, можно получить символ или воспользоваться методом charAt().

```js
let myString = "моя строка"
console.log(myString[4]) // 'c'
console.log(myString.charAt(4)) // 'c'
```

## Различия между обращением как к массиву и функцией charAt()

```js
let myString = "моя строка"
console.log(myString[30]) // undefined
console.log(myString.charAt(30)) // ""
```

## Длина строки

Одно из самых частых действий со строкой – это получение ее длины. Длина строки находится в свойстве length.

> Если нам необходимо отправить значение на сервер, для сохранения в базе данных, стоит задуматься о валидации этого значения, что бы оно не было слишком длинным.

```js
let myString = "моя строка"
console.log(myString.length) // 10
```

## Смена регистра

Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний.

> Например если необходимо сравнить ввод пользователя с ключевой фразой без учета регистра.

```js
console.log("моя строка".toUpperCase()) // "МОЯ СТРОКА"
console.log("МоЯ СтРоКа".toLowerCase()) // "моя строка"
```

## Поиск строки в строке

Для поиска строки в строке есть метод `indexOf(искомая_строка[,начальная_позиция])`.

Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено. Например:

```js
console.log("моя строка".indexOf("о")) // 1
console.log("МоЯ СтРоКа".indexOf("о", 4)) // 7
```

## Взятие подстроки

В JavaScript существуют 2 метода для взятия подстроки, с небольшими отличиями между ними.

1. [substring(start[, end])](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substring)
2. [slice(start [, end])](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substr)

## Сравнение символов

Символы сравниваются в алфавитном порядке 'А' < 'Б' < 'В' < ... < 'Я', но с некоторыми особенностями.

Все строки имеют внутреннюю кодировку Юникод. По этому коду сравниваются строки.

```js
console.log("а" > "Я") // true
console.log("ё" > "я") // true, т.к. ё находится после строчных
```

![](https://i.imgur.com/ifZoCVJ.png)

## Сравнение строк

Сравнение строк работает _лексикографически_, т.е. посимвольно.

> Например, при вводе капчи необходимо проверить пользовательский ввод с правильным результатом.

Сравнение строк str1 и str2 обрабатывается по следующему алгоритму:

1. Сравниваются первые символы: str1[0] и str2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить true или false. Если же они одинаковые, то…
2. Сравниваются вторые символы str1[1] и str2[1].
3. Затем третьи str1[2] и str2[2] и так далее, пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше.
4. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих – они равны.

## Получение символа по коду и код по символу

Метод String.fromCharCode(code) возвращает символ по коду:

```js
console.log(String.fromCharCode(8381)) // ₽
```

Метод str.charCodeAt(pos) возвращает код символа на позиции pos:

```js
console.log("строка".charCodeAt(0)) // 1089, код 'c'
```

# Типы undefined и null

Вспоминаем прошлые занятия.

> Чему равно значение по умолчанию объявленной переменной?

## Когда используется undefined

Переменная, не имеющая присвоенного значения, обладает значением undefined. Также возвращают undefined метод или инструкция, если переменная, участвующая в вычислениях, не имеет присвоенного значения. Функция возвращает undefined, если она не возвращает какого-либо значения.

```js
let a // undefined
let b = console.log(2 + 2) // выведет 4
console.log(b) // выведет undefined
```

В явном виде undefined **никогда** не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.

## Логические сравнения undefined

```js
// переменная x не была определена ранее
typeof x === "undefined" // вычислится в true без ошибок
x === undefined // выкинет ReferenceError
```

```js
let x
x === undefined // true
```

## Тип null

Мы используем тип `null`, если хотим показать отсутствие значения.
Переменная имеет значение `null`, если в ней нет явного значения.

## Сравнение null с нулём

Сравним null с нулём:

```js
null > 0 // false
null == 0 // false
null >= 0 // true
null == undefined // true
```

Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.

Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.

**Вывод:** Сравнивайте данные одинаковых типов. Избегайте нестрогого равенства.

## Отличия между null и undefined

```js
typeof null // object (баг в JS, должно быть null)
typeof undefined // undefined
null === undefined // false
null == undefined // true
```

# Преобразования типов

Предположим, что у вас есть строка, в которой хранится число, к которому необходимо прибавить число. Как это сделать?

```js
// Что будет выведено?
console.log("13" + 6)
```

## Почему получилось 136, а не 19?

При сложении строк движок JavaScript преобразует все параметры к строке и складывает их.

```js
console.log("13" + 6) // "13" + "6" = "136"
console.log("мой " + "дом") // "мой дом"
```

Это пример **неявного преобразования типов**

## Решение проблемы

Явное преобразование типов

## Явное преобразования типов

Значение можно явно преобразовать из одного типа в другой:

```js
//К числу
console.log(parseFloat("3.14")) // 3.14
console.log(parseInt("0xF", 16)) //15
console.log(Number("13") + 6) // 19
console.log(+"3.13") //3.14
//К строке
console.log(String(123)) // "123"
console.log("" + 12345) // "12345"
// К булеву
console.log(Boolean(123)) // true
console.log(!!123) // true
```

## Проблемы с преобразованием к числу

```js
console.log(Number("25abc") + 7) // NaN, упс... Вызов Number не примелит не-числовые строки
console.log(parseInt("25abc") + 7) // 32, сработало
```

## Новые типы

```js
let s = new Symbol("symbol_name") // Symbol
const theBiggestInt = 9007199254740991n // BigInt
const alsoHuge = BigInt(9007199254740991) // BigInt
const hugeHex = BigInt("0x1fffffffffffff") // BigInt
```

- [Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
- [Symbol на learn.javascript.ru](https://learn.javascript.ru/symbol)
- [BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
- [BigInt — новый тип данных в JS](https://medium.com/@hydrock/bigint-%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2-js-dd5c29446570)

**!** В реальной практике эти типы используются очень редко. Поэтому они выходят за рамки данного курса.

## Запуск из Node.js (демо)

А вы знали, что JavaScript код можно запускать не только в браузере?
![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Node.js_logo.svg/800px-Node.js_logo.svg.png)
Для запуска кода в среде Node следует выполнить команду `node ./main.js` (`./main.js` - путь к исполняемому файлу).
Если файл находится в текущей директории, то можно использовать `node main.js`.

---

## Чему мы научились?

1. Переменные и ограничения, связанные с их применением
2. Операторы, операнды, понятия и назначение
3. Новые типы данных и преобразования типов

---

# Домашнее задание

---

# Спасибо за внимание! Время задавать вопросы 🙂

## Пишите отзывы
