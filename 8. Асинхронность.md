# 3.3. Асинхронность

## План занятия

1. Понятие асинхронности
2. Асинхронные функции

## Синхронное выполнение

До настоящего момента весь код, что вы писали и мы проходили на лекциях, был синхронный. Принцип синхронного выполнения прост: код выполняется сразу. Иногда для выполнения работы коду требуется значительное время, но суть та же: программа начинает выполняться незамедлительно.

```javascript
const factorial = (n) => {
  for (var i = 1; n > 1; i *= n--);
  return i;
};
// 1 * 2 * 3 * ... * 50
factorial(50);
```

## Асинхронное выполнение

При разработке ПО бывают и специфические задачи:

1. Функция выполняется очень долго и хочется параллельно выполнять другой код. Например, пока ждем новых данных с сервера, можно работать со старыми.
2. Функция должна выполниться в определённое время. Например, будильник или рассылка Email-уведомлений.
3. Неизвестно точно, когда функция выполнится. Например, экран телефона необходимо включить только тогда, когда он нажмёт на кнопку «Power».

Типичный случай из непрограммирования. В данном примере цвет кнопки изменится только при наведении на неё. Когда это может произойти и произойдёт ли вообще - зависит только от посетителя.

```html
<button>Нажми на меня</button>
```

```css
button:hover {
  background: red;
}
```

## setTimeout

Для отложенного вызова функций в браузере есть функция _setTimeout(fn, ms)_, где
_fn_ - функция, которую нужно запустить через _ms_ миллисекунд (1000 миллисекунд = 1 секунде).

Например, этот код через 1 секунду добавит в консоль приветствие:

```javascript
const showGreeting = () =>
  console.log(
    "Поздравляем, вы стали обладателем $1000! но мы их вам не дадим!"
  );

setTimeout(showGreeting, 1000);
```

## Неточность вызова

Тем не менее, _showGreeting_ из прошлого примера выполнится не обязательно через 1 секунду.
Для наглядности, 10 раз вызовем _setTimeout_ с одним и тем же параметром:

```javascript
const checkDelay = (index, delay) => {
  const start = new Date();
  setTimeout(() => {
    const end = new Date();
    const delay = end - start;

    console.log(`${index}: Задержка между вызовом : ${delay} мс`);
  }, delay);
};

for (let i = 0; i < 10; i++) {
  checkDelay(i, 1000);
}
```

Каждый раз вывод в консоль может немного отличаться, но вот пример вызова:

[![2019-01-18-12-34-30.png](https://i.postimg.cc/63wyg25M/2019-01-18-12-34-30.png)](https://postimg.cc/sB6jZ2WW)

## Один поток

Данная особенность связана с тем, что код JavaScript выполняется в одном потоке.
Проще говоря, в нашем случае _showGreeting_ выполнится, только если в настоящий момент не выполняется вообще ничего.

Если же параллельно с _showGreeting_ выполняется какой-либо другой код,
интерпретатор JavaScript сначала закончит выполнять его и только потом возьмётся за _showGreeting_.

Для демонстрации нам необходимо сделать два действия: уменьшить задержку для наглядности и нагрузить интерпретатор долгими вычислениями:

```javascript
for (let i = 0; i < 10; i++) {
  checkDelay(i, 10);
}
```

Вот «эталонный» результат, который тоже может немного отличаться от вызова к вызову:

[![2019-01-18-12-47-10.png](https://i.postimg.cc/4NzLzjHV/2019-01-18-12-47-10.png)](https://postimg.cc/Czxs0PNx)

Теперь «нагрузим» JavaScript бесполезной долгой работой:

```javascript
// делает много бесполезной работы. Главное, чтобы долго!
const idle = (n) => {
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += i;
  }
};

for (let i = 0; i < 10; i++) {
  checkDelay(i, 10);
  idle(1000000);
}
```

И результат существенно изменится:

[![2019-01-18-12-49-49.png](https://i.postimg.cc/tgtpwBcx/2019-01-18-12-49-49.png)](https://postimg.cc/SXsBzfkS)

Это значит, что функция в _setTimeout_ будет вызвана, только если у неё будет такая возможность. JavaScript не несёт никакой ответственности за то, что _setTimeout_ сработает вовремя, но обещает это сделать как можно раньше в рамках заданной задержки.

## Функции обратного вызова

Это всего лишь термин и ничего кроме. _Функцией обратного вызова_ (callback) называется такая, которая:

1. Передаётся в другую функцию высшего порядка (HOF) как аргумент.
2. HOF должен вызвать эту функцию по достижению определённого условия.

Рассмотрим прошлый пример:

```javascript
const showGreeting = () => console.log("Добрый день, я консольный бог!");

setTimeout(showGreeting, 1000);
```

В нашем случае функцией высшего порядка является _setTimeout_, а функцией обратного вызова является _showGreeting_.

## Минимальная задержка

Вы можете вызывать _setTimeout_ и без параметра временной задержки. В таком случае функция обратного вызова сработает как можно скорее (опять же, без каких-либо обязательств).

Пример 1:

```javascript
const showGreeting = () => console.log("Добрый день, я консольный бог!");

setTimeout(showGreeting);
```

Пример 2:

```javascript
const checkDelay = (index, delay) => {
  const start = new Date();
  setTimeout(() => {
    const end = new Date();
    const delay = end - start;

    console.log(`${index}: Задержка между вызовом : ${delay} мс`);
  }, delay);
};

for (let i = 0; i < 10; i++) {
  // второй параметр в данном случае будет равен undefined
  checkDelay(i);
}
```

Пример вызова:

[![2019-01-18-13-07-04.png](https://i.postimg.cc/YqzsgTTZ/2019-01-18-13-07-04.png)](https://postimg.cc/mthjWpLy)

Вызов без второго аргумента равносилен указанию значения 0. У каждого браузера всё равно есть минимальный порог, меньше которого задержка не будет.

```javascript
const showGreeting = () => console.log("Добрый день, я консольный бог!");

// можно было и не указывать 2 параметр
setTimeout(showGreeting, 0);
```

## clearTimeout

Запланированную задачу можно отменить с помощью функции _clearTimeout_. Для этого необходимо передать идентификатор таймаута, возвращаемый от _setTimeout_.

```javascript
// сообщение в консоль не будет выведено
const id = setTimeout(() => console.log("Я хочу жить :("), 500);

clearTimeout(id);
```

```javascript
// сообщение в консоль не будет выведено
const sendPayment = () => console.log("Вам начислена зарплата!");
const isCrisis = true;
const id = setTimeout(sendPayment, 1000);

// не выплачиваем сотрудникам деньги. У нас кризис!
if (isCrisis) {
  clearTimeout(id);
}
```

## setInterval (демо)

Аналогично с _setTimeout_, _setInterval_ запускает функцию обратного вызова.
Но делает это постоянно!

```javascript
const areWeHome = () => console.log("Мы уже приехали?");
// будет запускать areWeHome до посинения
setInterval(areWeHome, 1000);
```

Если для удаления таймаута используется `clearTimeout`, то для удаления интервала используется `clearInterval`.
Функция `clearInterval` принимает id интервала и удаляет его (если он существует).

[![shrek.png](https://i.postimg.cc/zD6Kk1Lv/shrek.png)](https://postimg.cc/Wtmd2Cwc)

## Болезнь запуска

Как и у _setTimeout_, _setInterval_ также «болеет» непредсказуемым временем запуска функций обратного вызова.

```javascript
let start = new Date();
setInterval(() => {
  const end = new Date();
  const delay = end - start;
  console.log(`Задержка: ${delay}`);
  start = new Date();
}, 1000);
```

Пример выполнения:

[![2019-01-18-14-42-34.png](https://i.postimg.cc/8CkSccV0/2019-01-18-14-42-34.png)](https://postimg.cc/hXYw3SvL)

## Передача аргументов

Все аргументы, которые передаются в _setTimeout_ и _setInterval_ после второго, становятся аргументами _callback-функции_ в момент вызова:

```javascript
// выведет сообщение «Блиц, скорость без границ!» через 1с.
setTimeout(console.log, 1000, "Блиц, скорость без границ!");
```

```javascript
const sum = (a, b) => a + b;

// Выведет 29 через 1с.
setTimeout(sum, 1000, 10, 19);
```

---

## Работа с HTTP

[Наиболее распространенный случай работы с асинхронным кодом — запросы по HTTP.](https://repl.it/repls/CourteousPoisedBrace)

---

### Рассмотрим этот код

```js
// 1. Создаем запрос
var xhr = new XMLHttpRequest();

// 2. Опрелеяем функцию обратного вызова
xhr.onreadystatechange = processResponse;

// Этот код выполниться кода запрос будет в пути
function processResponse(e) {
  if (xhr.readyState === 4) {
    // Запрос выпонился!
    console.log(xhr.responseText);
  } else {
    // Запрос еще выполняется
    console.log("Загружаем ...");
  }
}

// 3. Определяем куда и как отправлять запрос
xhr.open("GET", "employees.json", true);

// 4. Отправляем запрос
xhr.send();

console.log("Другая важная работа ...");
```

---

### Живой пример

https://repl.it/repls/CourteousPoisedBrace

---

### Результата работы

```js
Загружаем ...
Другая важная работа ...
Загружаем ...
Загружаем ...
[
  {
    "name": "Jim",
    "inOffice": false
  },
  {
    "name": "Joe",
    "inOffice": true
  },
  {
    "name": "John",
    "inOffice": true
  }
]
```

---

## Оптимизация вычислений

### Проблема долгих вычислений

Второй вид функций: выполняющиеся очень долго. При больших значениях _n_ страница будет существенно подвисать:

```javascript
const sum = (n) => {
  let sum = n;
  for (let i = 0; i < n; i++) {
    sum += i;
  }
  return sum;
};

sum(100000);
```

### Решение

Интервалы и таймеры - идеальное решение для долгих или рекурсивных вычислений.
С помощью них мы можем проделывать полезную работу небольшими порциями, не нагружая страницу.

```javascript
// вычисляем сумму от 0 до n, по itemsPerStep элементов за раз
const sumStep = (n, itemsPerStep, onload) => {
  const size = Math.ceil(n / itemsPerStep); // количество шагов
  let index = 0; // текущий шаг
  let sum = 0; // сумма вычислений

  // эта функция будет вызываться каждые 500 мс
  return () => {
    // окончание вычислений
    if (index === size) {
      onload(sum);
      return;
    }

    // начальные и конечные значения шага
    const start = index * itemsPerStep;
    const end = Math.min((index + 1) * itemsPerStep, n + 1);

    // сами вычисления
    for (let i = start; i < end; i++) {
      sum += i;
    }

    console.log(`Шаг ${index}: ${sum}`);
    index++;
    // планируем новый шаг
    scheduleStep();
  };
};

// функция обратного вызова для вывода результата
const onload = (result) => console.log(`Результат вычислений: ${result}`);

// задаем начальные настройки
const step = sumStep(1000000, 1000, onload);
const scheduleStep = () => setTimeout(step, 500);

scheduleStep();
```

## Таймауты в интерфейсах

Использование таймаутов и интервалов в JavaScript - довольно распространенное явление. На веб-сайтах вы наверняка встречались со следующими примерами:

1. Появление всплывающих окон в заданное время.
2. Таймеры обратного отсчёта на странице («До конца акции осталось...»).
3. Показ подсказок при поиске только по окончанию ввода в текстовое поле.
4. Простая анимация.
5. Автоматическая смена слайдов в фотогалерее.
6. Проверка в простых чатах новых сообщений.

## Вызов setTimeout для метода объекта

Представим, что у нас есть объект и мы хотим вызвать его метод через определенное время.

```js
const user = {
  firstName: "Antonio",
  sayName() {
    console.log("My name is " + this.firstName);
  },
};
user.sayName(); // работает
setTimeout(user.sayName, 500); // "My name is undefined"
```

Почему так? Посмотрим другой пример:

```js
let func = user.sayName;
setTimeout(func, 500); // "My name is undefined"
func(); // "My name is undefined"
```

Причина в том, что контекст определяется во время вызова (а не объявления) по правилу "объект перед точкой". `func` равная `user.sayName` вызывается с this = window.
Таким образом, для this.firstName пытаемся получить window.firstName, которого не существует.

## Как исправить

Существует несколько способов исправить данную ситуацию. С одним из них вы уже знакомы из лекции "Декораторы". Это `func.call`

```js
//1
setTimeout(function () {
  func.call(user); // установить this = user при вызове
}, 500);

//2
setTimeout(function () {
  user.sayName();
}, 500);

//3
setTimeout(
  () => user.sayName(), // аналогично предыдущему, стрелочная функция
  500
);
```

Последний способ является наиболее распространенным.

## Bind

Еще одним выходом является привязка функции к контексту с помощью `let newFunc = oldFunc.bind(newThis)`:

```js
user.sayNameBinded = user.sayName.bind(user);
// или даже так, так как старая функция нам больше не нужна
user.sayName = user.sayName.bind(user);
// или так
let func = user.sayName.bind(user);
```

Bind из старой функции `user.sayName` создаёт новую с привязанным контекстом.

```js
setTimeout(user.sayName); // "My name is Antonio"
setTimeout(func); // "My name is Antonio"
```

## Вызов setTimeout в методе объекта

```js
const user = {
  firstName: "Antonio",
  sayName() {
    setTimeout(function () {
      console.log("My name is " + this.firstName);
    });
  },
};
user.sayName(); // "My name is undefined
```

Причина та же. Внутри `setTimeout` this = window.

## Как исправить?

```js
const user = {
  firstName: "Antonio",
  sayName() {
    setTimeout(() => {
      console.log("My name is " + this.firstName);
    });
  },
};
user.sayName(); // "My name is Antonio
```

Так как стрелочная функция не имеет собственного this, то this будет взято из замыкания (лексического окружения)
Этот код аналогичен следующему

```js
const user = {
  firstName: "Antonio",
  sayName() {
    let savedThis = this;
    setTimeout(function () {
      console.log("My name is " + savedThis.firstName);
    });
  },
};
user.sayName(); // "My name is Antonio
```

## Чему мы научились?

1. Разобрались с основами таймеров и интервалов.
2. Научились работать с датами.
3. Узнали о «Болезни запуска» _setTimeout_ и _setInterval_.
4. Научились оптимизировать долгие и рекурсивные вычисления.
5. Узнали разницу между синхронной и асинхронной работой.
6. Разобрались как отправлять HTTP-запросы и обрабатывать результаты.
7. Познакомились с новым способом привязки контекста (bind)

---

# Домашнее задание

Давайте посмотрим ваше [домашнее задание](https://github.com/netology-code/bjs-homeworks/tree/master/3.3-async)

- Вопросы по домашней работе задаем в группе Slack!
- Задачи можно сдавать по частям.
- Зачет по домашней работе проставляется после того, как приняты все 3 задачи.

---

## Спасибо за внимание! Время задавать вопросы 🙂

```

```

```

```
