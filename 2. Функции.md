# 2 Функции

## План занятия

1. Чистые функции
2. Аргументы и rest оператор
3. Функциональные выражения
4. Стрелочные функции
5. Контекст выполнения
6. Замыкания
7. Функции конструкторы
8. Функции высшего порядка
9. Анонимные и самовызывающиеся функции

## Что мы уже знаем о функциях

К этому моменту мы умеем объявлять функции с параметрами и без. С возвращаемым значением и без.

1. Приведите примеры таких функций.
2. Сколько переменных может возвращать функция?
3. Что мы обычно делаем с возвращаемым значением?
4. Сколько раз может быть использован return внутри функции?
5. Если у функции есть аргумент, но он не передан, какое значение у него будет.
6. Кто помнит, как задавать значения аргументов по умолчанию?

---

## Чистые функции

Чистые функции — строительные блоки в функциональном программировании. Их преимущества - простота и тестируемость.

- Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов

- Нет побочных эффектов

Чистая функция:

```js
const add = (x, y) => x + y;
add(2, 4); // 6
```

---

## Примеры побочных эффектов

Примеры побочных эффектов:

1. Видоизменение входных параметров
2. console.log
3. HTTP вызовы (AJAX/fetch)
4. Изменение в файловой системе
5. Запросы DOM

Пример:

```js
let x = 2;
const add = (y) => {
  x += y;
  return x;
};
console.log(add(4)); // 6
console.log(add(4)); // 10
```

## ...rest параметры

Если мы не знаем, сколько будет аргументов, на помощь приходит rest параметр:

```javascript
function getArgs(...data) {
  console.log(data);
}

getArgs(2, 4, 5, 6, 7, 10, 45, 11);
```

В данной ситуации в консоль попадёт массив всех переданных в функцию аргументов:

[![2018-12-01-15-33-04.png](https://i.postimg.cc/RZ751SZR/2018-12-01-15-33-04.png)](https://postimg.cc/PC5RTkZp)

## Переменное число аргументов

Переменное число аргументов чаще всего используют при однородных значениях:

```javascript
function sum(...args) {
  let total = 0;
  for (let i = 0; i < args.length; i++) {
    total += args[i];
  }
  return total;
}

console.log(sum(2, 4, 5, 16, 7, 10, 11)); // 55
```

## ...rest и остальные аргументы

В случае, когда функция содержит не всегда однородные значения, их можно вынести в начало списка аргументов. При этом **_...rest_ должен быть в конце списка аргументов!**
Например, создадим функцию, которая создаёт тариф оплаты вместе со списком преимуществ

```javascript
function showTariff(name, ...advantages) {
  let text = `Тариф ${name}\nПреимущества:\n`;
  for (let i = 0; i < advantages.length; i++) {
    text += `-${advantages[i]}\n`;
  }

  console.log(text);
}

showTariff("Базовый", "Кровать на чердаке", "Беседы с дядей Витей");
showTariff(
  "Оптимум",
  "Кофе в постель без чашки",
  "Раздельный санузел",
  "Гарантия на возврат 5%"
);
```

[![2018-12-01-16-03-46.png](https://i.postimg.cc/N0qwhy5m/2018-12-01-16-03-46.png)](https://postimg.cc/MnDLVp0p)

# Функциональные выражения

## Функциональные выражения

В переменную можно поместить всё что угодно, даже функцию! (вспомним пример, где возвращается `console.log`)

```javascript
let sum = function (a, b) {
  return a + b;
};
```

Такая конструкция называется _функциональным выражением_. **Это просто ещё один способ объявить функцию.** Мы можем также обратиться к переменной, в которой находится функция, как и к обычному объявлению функции:

```javascript
console.log(sum(3, 4)); // 7
```

Иными словами, _функциональным выражением_ называется всё, что позволяет использовать функцию как значение.

## Объявления функций vs функциональные выражения

Между _функциональными выражениями_ и _объявлениями функций_ есть одна принципиальная разница: _функциональные выражения_ можно использовать только **после** присвоения функции в переменную, _объявления функций_ доступны **независимо от места** объявления:

```javascript
// Выдаст ошибку
console.log(takeFive()); // TypeError: takeFive is not a function. (In 'takeFive()', 'takeFive' is undefined)

let takeFive = function () {
  return 5;
};

// Из-за ошибки с первым console.log, эта строка вообще не выполнится
console.log(takeFive());
```

```javascript
console.log(takeFive()); // 5

function takeFive() {
  return 5;
}

console.log(takeFive());
```

Такой принцип объявления функции называется _поднятием_ (hoisting). Грубо говоря, интерпертатор **дважды** обрабатывает наш код перед тем, как мы увидим конечный результат отработки кода.

# Стрелочные функции

## Полный и краткий синтаксис

Проблема: обычные функции достаточно длинные, необходимо писать объявление функции и её тело.
В переменных sum, sumArrow и sumArrowBlock будут содержаться идентичные функции.

```js
let sum = function (a, b) {
  return a + b;
};
let sumArrow = (a, b) => a + b; // краткий синтаксис, используется если в функции одно действие
let sumArrowBlock = (a, b) => {
  return a + b;
}; // блочный синтаксис
```

## Скобки в стрелочных функциях

Если в функции 1 аргумент, то скобки **не обязательны**

```js
let multiply = (a) => a * 2; // аргумент "а" не обёрнут в скобки
console.log(multiply(4)); // 8
```

Если аргументы отсутствуют или их больше одно, то скобки **обязательны**.

## Функции как методы объектов

Мы уже знакомы с объектами из курса pbj.
Функции могут быть свойствами объектов, в этом случае они называются методами:

```js
let human = {
  name: 'Alex',
  age: '27',
  sex: 'male',
  dojob: function () {
    console.log("I'am working");
  }
  eat() {
    console.log("I'am eating")
  }
  sayName: function () {
    console.log(`Имя: ${this.firstName}`)
  },
  sayNameArrow: () => console.log(this.name)
}
```

Чтобы говорить о this в стрелочных функциях надо сначала поговорить о this вообще и контексте выполнения.

# Контекст выполнения

## Глобальный объект window

Любая var-переменная или функция, определённая в _глобальной области видимости_, хранятся в рамках _глобального объекта window_.

```javascript
var seven = 7;
function takeFive() {
  return 5;
}

console.log(seven); // 5
console.log(window.seven); // тоже 5

console.log(takeFive()); // 5
console.log(window.takeFive()); // тоже 5
```

## Контекст. this

У любой функции есть ключевое слово _this_. Оно указывает на тот объект, к которому эта функция прикреплена.

В глобальной области видимости _this_ указывает на _window_.

```javascript
function getThis() {
  console.log(this);
}

let person = {
  getThis,
};

person.getThis(); // объект person
window.getThis(); // объект window
getThis(); // объект window
```

## Другое понимаение

`this` вообще нужен в том случае - когда функция вызывается как метод объекта.

```js
sayHi(); // просто вызов
human.sayHi(); // вызов как метод объекта
```

Это позволяет инкапсулировать всю логику в объект. Например.

```js
human.work(); // вызов как метод объекта
human.sleep();
human.growChildren();
human.die();
```

Все эти функции внутри обращаются к свойствам **своего** объекта использую `this`.

## Контекст. Строгий режим

В **строгом режиме** _this_ для функций глобальной области видимости, вызыванных без _window_ имеют значение _undefined_.

```javascript
"use strict";
function getThis() {
  console.log(this);
}

let person = {
  getThis,
};

person.getThis(); // объект person
window.getThis(); // объект window
getThis(); // undefined
```

## Как this позволяет избавится от дублирования кода?

До _this_:

```javascript
let ivan = {
  firstName: "Иван",
  showName() {
    console.log(`Имя: ${ivan.firstName}`);
  },
};

let oleg = {
  firstName: "Олег",
  showName() {
    console.log(`Имя: ${oleg.firstName}`);
  },
};

ivan.showName(); //
```

После _this_:

```javascript
function showName() {
  console.log(`Имя: ${this.firstName}`);
}

let ivan = {
  firstName: "Иван",
  showName,
};

let oleg = {
  firstName: "Олег",
  showName,
};
```

# Функции конструкторы

---

## Пример

Предположим, реализуем CRM, для этого создаем объект клиента.

```
const person = {};
person.name = 'Vasya';
person.gender = 'M';
```

Переиспользовать такой код не получится, нарушается принцип DRY (будет повторяться логика создания и наполнения объекта).

Решение: использовать функцию конструктор.

---

## Конструктор объекта

**Конструктор** - специальный блок инструкций, вызываемый при создании объекта.

```javascript
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
}
```

---

## Оператор new

Позволяет создавать объекты через вызов функций.
Особенности работы функций, вызванных через оператор new:

- Создаётся новый пустой объект
- Ключевое слово this получает ссылку на этот объект
- Функция выполняется
- Возвращается `this` без явного указания

---

## Создание новых объектов при помощи оператора new (демо)

Таким образом создание новых объектов может быть реализовано вызыванием обычной функции с оператором new. Подробнее в лекции 7.

```js
function Car(engine) {
  this.engine = engine;
}

const car = new Car("v8");
```

---

# Функции высшего порядка

> Функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата.

_High ordered function_ или _HOF_ — функция высшего порядка в переводе с английского.

## Принимаем функцию в качестве аргумента

Для начала разберем простой пример:

```javascript
function execute(func) {
  func();
}

function hello() {
  console.log("Привет, я функция!");
}

execute(hello);
execute(function () {
  console.log("Я функциональное выражение!");
});
```

## Функции передаются без скобок

Обратите внимание, что функцию `hello` мы передаем просто по имени.

```javascript
function execute(func) {
  func();
}

function hello() {
  console.log("Привет, я функция!");
}

execute(hello());
```

Мы передали **результата выполняния hello**. Так как функция `hello` ничего не возвращает, то внутри функции `execute` переменная `func` будет указывать на `undefined`, а не на функцию `hello` как ожидалось изначально.

## Возвращаем функцию

Когда мы говорили о замыканиях, у нас уже был пример функции, которая возвращает функцию. Переделаем её в стрелочную.

```javascript
let name = "Ann";
function generateFunction() {
  let name = "Mark"; // переменная в замыкании в момент создания
  const sayName = () => {
    console.log(name);
  };
  return sayName;
}

const newFunc = generateFunction();
newFunc();
```

## Возвращаем функцию из функции (еще пример)

Разберём пару функций

```javascript
function example1() {
  let innerExample1Func = () => "innerExample1Func_result";
  return innerExample1Func();
}

function example2() {
  let innerExample2Func = () => "innerExample2Func_result";
  return innerExample2Func;
}
```

какие значения значения будут получены при вызове функций `example1` и `example2` ?

## Возвращаем функцию из функции

![](https://sun9-70.userapi.com/c857528/v857528317/18e632/UBhJG4fCpYA.jpg)

## Вызываем полученную функцию

Так как из функции возвращается функция, то вызывать её можно просто дописав `()`.
![](https://sun9-9.userapi.com/c857528/v857528317/18e63a/eOcNrO1WBHM.jpg)

В первом вызове результат функции `example2` сохраняется в переменную `resultFunc`. Затем `resultFunc` вызывается как функция.
Во втором вызове результат функции `example2` не сохраняется, а сразу вызывается как функция.

# Анонимные и самовызывающиеся функции

Вспомним наш пример с функцией, работающей с переменной в замыкании и приведем аналогичный пример.

```js
function counterGenerator() {
  let count = 0;
  function showCounter() {
    console.log(count);
  }
  function increaseCounter() {
    count += 1;
  }
  return [showCounter, increaseCounter];
}
const [showCounter, increaseCounter] = counterGenerator(); // деструктуризация
showCounter(); // 0
increaseCounter();
increaseCounter();
showCounter(); // 2
```

Переменная `count` существует только в замыкании. Получить|изменить её иначе нельзя.

---

## Воспользуемся анонимной самовызывающейся функцией

```js
const [showCounter, increaseCounter] = (function () {
  let count = 0;
  function showCounter() {
    console.log(count);
  }
  function increaseCounter() {
    count += 1;
  }
  return [showCounter, increaseCounter];
})();

increaseCounter();
showCounter(); // 1
```

## Зачем?

Главной идеей является то, что анонимная функция вызывается сразу после своего объявления. Преимущество от использования самовызывающихся функций вы получите, если нужно выполнить код один раз и сохранить его резульататы во "внешней среде" (без объявления глобальных переменных).

## Имя функции

Функция тоже объект. И поэтому у неё есть некоторые свойства и методы. Например свойство `name` — содержит строку, название функции:

```javascript
function mult(a, b) {
  return a * b;
}

console.log(mult.name); // mult
```

# Домашнее задание

Давайте посмотрим ваше [домашнее задание](https://github.com/netology-code/bjs-homeworks/tree/master/2.1-functions)

- Вопросы по домашней работе задаем в группе Slack!
- Задачи можно сдавать по частям.
- Зачет по домашней работе проставляется после того, как приняты все 3 задачи.

---

## Спасибо за внимание! Время задавать вопросы 🙂
